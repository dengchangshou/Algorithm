1.十六进制加法
直接用%x进行运算。输入用scanf("%x",&a),x换为大写X可使输出全为大写字母。
十六进制减法输出不能为负数，所以要先将结果转换为正数再输出。

2.runtime  error（运行时错误）就是程序运行到一半，程序就崩溃了。
根据经验，大多数情况是因为程序员对内存的理解不透彻导致错误应用引起的，简单的说几个常见的：
①除以零的情况，比如1/0此类的。
②数组越界：int a[3]; 但程序中的要求却至少是一个为100的数组。
③指针越界：int * p; p=(int *)malloc(5 * sizeof(int)); *(p+1000000)=10;
④使用已经释放的空间：int * p; p=(int *)malloc(5 * sizeof(int));free(p); *p=10;
⑤数组开得太大，超出了栈的范围，造成栈溢出：int a[100000000];Runtime error。

3.求类似于1/(n*n)形式的分数,为了防止溢出，应采用1/n/n的形式。

4.分数化小数，小数点后的有效位数超过各种数据类型时，手算怎么算，计算机就怎么算。

5.浮点数的陷阱：
double i;  
for(i = 0; i != 10; i += 0.1) //会进入死循环 
    printf("%.1lf\n", i); 

if(0.1+0.1+0.1 == 0.3)   //永远不会输出equal
    printf("equal\n");  
else  
    printf("not equal\n");  

产生上述陷阱的原因

实际上，计算机中的所有数据都用二进制表示，包括浮点数。这就导致某些浮点数不能用二进制精确表示，例如0.1（这很容易理解，就像10/3不能被十进制精确表示一样）

进一步地说，浮点数是采用分数+指数来表示的，例如

0.5 = 1/2

0.75 = 1/2 + 1/(2^2)

0.875 = 1/2 + 1/(2^2) + 1/(2^3)

0.1 = 1/(2^4) + 1/(2^5) + 1/(2^8) + ...

其中0.1只能无限循环下去，这就意味着0.1在计算机中不能被精确表示，因此产生上述两个陷阱也就很容易理解

6.比较大的数组应尽量声明在main函数外，否则程序可能无法运行。

7. a[n++] = x    <==>   { a[n] = x; n++; }

8.数组复制,将数组a复制k个元素到数组b， memcpy(b,a,sizeof(DataType)*k);

9.输入字符串数组scanf("%s", s), 不要在s前面加上“&”。字符串数组char s[maxn][maxl]可以用scanf("%s", s[i])读取第i个字符串，scanf("%s",s)遇到空白字符（空格、TAB）会停下来。

10. %03d 输出三位数，不足的用0补全。  %5d 输出五位数，不足五位在前面补空格。

